    大家下午好，今天跟大家分享一下怎么做一个简单的10位无符号除法器，这个东西其实是之前布置除法器作业的时候顺便做的。

通常我们要做一个东西的时候都是先自顶向下的构思，先弄清实现这个功能的整体方法或思路，然后再把这个方法分解成一个个小步骤，交给下面的一个个小模块的完成。所以现在我们也按照这种思路，先从整体上弄清楚一个除法器是怎么实现的。

一、除法器的实现方式

    其实实现除法器的方法很多的，布置作业的时候老师要求的是用查表法来做的。这种方式其实是一种用空间换时间的做法。还记得那时候本来是要做10位的，后面因为芯片的ROM不够后面改成做8位的，也说明了这个方法对空间的要求还是挺高的，但是好处是显而易见的，程序简单，运算结果秒出,只要等一个上升沿，结果就出来了。
    如果我们存储空间不够的话应该怎么办，可能我们就得用时间来换空间了，这也是今天用的方法。
    那有没有既不需要很大的空间，速度又很快的方法呢？其实是有的，在quartus的lpm参数化模块库中就有一个lpm_div,它不需要多少空间，同时结果基本是无延迟地输出的，也就是你给一个被除数和除数结果就立刻就输出来了。当然这个我只能调用，具体是怎么实现的我是不懂的。
    回到正题，我们举一个实例来说明除法是怎么实现的
     因为10位太长了，这里就举一个4位的除法说明一下，基本原理都是一样的。比如说13除以4吧
     最直接的想法就是竖式计算吧

    1.首先我们需要一个寄存器，位数是被除数和除数位数相加，在这个例子里被除数和除数都是4位，所以移位寄存器是8位的，把前4位用0填充，后4位填入被除数。接下来开始左移，每移位一次将前4位和除数进行比较，若小于除数，则给移位空出的最后1位填0，其余不变；若大于除数，则将前4位减去除数，同时给最后1位填1。4次移位结束后，我们发现前四位变成了余数，后四位则变成了商。13除以4等于3余1。
    其实这跟除法竖式计算很相似的，只不过竖式把前面几步省略了，直接移到了第3位，商前面的0也给省了不写，还有就是这种方法利用了移位后出现的空缺，然后将商填到里面。
好了，实验方案确定之后，接下来我们将这个方案分解成一个个小步骤:
从上面的图示可以看出，这种除法器其实很简单，它无非就是一直在重复地做两件事，
第一件：移位，将移位寄存器左移一位
第二件事：更新：在移完位后，通过与除数的比较更新寄存器的高4位，并给最后一位空缺位填值
重复的次数取决于被除数和除数的位数，这个例子是4位的，所以要重复做4次，后面实际上做的是10位的，所以要重复做10次，原理是一样的。
那我们就要做这两个小模块来分别完成移位和更新这两件事，
除此之外，因为移位和更新这两件事是有先后关系的，必须先移完位才能更新，同时下一次移位又必须等上一次更新完了之后才能进行，所以在这里又牵涉到时序控制的问题，我们还需要有一个是时序控制的模块
还有因为我们知道当除数为0的时候是没有实际意义的，所以我们还要有一个模块来对除数进行检测，若等于0就不算了。
基本上就是上面几个模块了，到这里我们就完成了自顶向下的构思工作了，接下来我们来实际做这个除法器的时候就反过来了，我们要从最底层开始，把每个子模块做好再自下而上地把除法器搭出来。

二、子模块制作
首先我们先挑最简单的来做吧
1.时序控制模块
因为这个除法器的时序比较简单，所以这个模块也比较简单，只要生成下图这样的波形就可以了，第一行是输入的主时钟，我们把主时钟的上升沿分成两份，分别来驱动移位和更新这两个模块了，要注意的是，要先给移位模块上升沿再给更新模块上升沿。
（看图）在这里进行第一次移位，然后进行第一次更新 如此重复


到这里大家就明白了，为什么说这种方法是用时间换空间，这个除法器没办法像查表法一样快速出结果，在被除数和除数输进去后，如果每做一件事要一个时钟上升沿，10位除法器要等20个时钟周期才能得到结果。

2.除数检测模块
这个模块也很简单，检测到输入除数为0的话，将输出的标志信号IsDivisorZero置1，并停止计算，将输出的商和余数置0。


因为比较上面两个模块比较简单，所以这里我就不嗦讲代码了。接下来进入除法器的两个主要部分了，第一个是移位模块


3.移位模块
它的主要功能是对寄存器进行移位，说是移位模块，但是实际上这个模块做的不止是移位而已，他还需要对移位次数进行计数，在计数器的值为0，也就是第一次移位之前，要将寄存器的值进行初始化，也就是高10位填入0，低10位填入被除数，在移位10次后，计数器要回到0重新从输入端取值被除数和除数重新进行寄存器的初始化。
说完功能，接下来可以看一下这个模块的实体entity
很明显，我们需要给一个时钟和重置信号，给被除数inDividend是初始化寄存器需要用到，
还有一个inUpdatedReg这个是更新模块的输出，因为当前时刻的移位需要上一时刻的更新模块的输出


接下来我们来看看结构体的程序

讲代码。。。


代码其实很简单吧

4.更新模块
更新模块主要的功能是对移位模块的输出进行修改，具体是比较除数和寄存器高10位的数值的大小，如果寄存器高10位更大，就将高10位减去除数，然后将移位空出的最后一位天上1，如果寄存器高10位数比较小，那就不用减了，并给最后一位填上0。
因为这个模块需要用到比较和相减，我们需要做一个10位的全减器 所以我们把这个模块进一步细分成了两个模块
10位的全减器 还有剩下来的寄存器更新模块
其中全减器的原理跟之前做的全加器的原理是一样的，所以也不细说，接下来看一下剩下来的更新模块

同样的，我们先看一下实体entity是怎样的


接下里我们看一下代码 结构体前面的就没有列出来了



接下来我们看一下除法器的整体连接图

波形图展示 讲一下bdf连线含义


三、总结

今天跟大家大概分享了一种除法器的实现方法，先从整体上对除法器的功能进行介绍，然后从组成除法器的每个子模块入手，对代码进行了简单的说明。其实这是一个比较简单的例子，但是包含了一个完整的FPGA系统的常见组成部分，所以才选了这个题目跟大家分享。然后就没了。



