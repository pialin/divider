FPGA课程论文

除法器的FPGA实现

一、除法器的实现方式
实现除法器的方式并不唯一，我们可以大致根据实现功能所需消耗存储单元的多少以及除法运算所需时间的长短进行如下分类：
1.查表法
查表法是一种利用大量的存储单元来换取运算时间以及程序实现复杂度的一种运算实现方式。基本思想是先将运算的所有结果算出来根据一定的规则存放到存储单元里面，然后程序只需要把输入的运算操作数映射成相应的地址，再将存储器里面的数据读取出来就可以了。
查表法的优势有，首先程序的设计被大大简化;其次这种方法对于具体要实现的运算类型并没有什么要求，具备通用性，也就是说这一思想可以应用于很多不同类型的运算，实际操作的时候只需要将存储器中的数据按需求替换即可。

2.移位寄存器法
移位寄存器法是一种模仿竖式计算的实现方式。利用一个移位寄存器进行重复移位和更新就可以完成除法运算。移位寄存器法相比查表法只需要很少的硬件资源，但是它的缺点在于完成一次除法运算需要多个时钟周期，所以归根结底这是一种“时间换空间”的实现方式。而且这种方法也不具备查表法那样的通用性，而是一种针对除法的实现方法。



3.参数化模块库法
实现除法还可以通过调用Quartus提供的参数化模块库中的除法模块LPM_DIV来实现，当然这样做需要获得Altera的许可，并且硬件也必须包含相应的模块。

本文主要围绕的是第二种方法展开，在FPGA上用移位寄存器法实现了一个简单的十位无符号除法器。


二、移位寄存器法原理
1.竖式计算
    移位寄存器法其实模仿了常用的除法竖式计算，右图给出了一个4位的除法竖式计算的示意。可以发现，在二进制情形下，竖式计算其实是通过将被除数的高3位和除数进行比较，发现除数更大，所以在商的位置填1，并且将高3位减去除数，剩余的数再与被除数的下一位组成一个3位数，再次与除数进行比较，依此类推。
2.移位寄存器法的实现步骤
(1)首先我们需要一个位数为被除数和除数位数之和的寄存器，然后对其进行初始化：将被除数填入低半部分，剩余的高位填'0';
(2)将寄存器整体左移，将移位后的高半部分与除数作比较，若比除数更大，则将高半部分减去除数，并给移位空出的最低位填'1'，否则高半部分不做改变，最低位填'0'；
(3)判断移位次数是否超过被除数位数，若是则将寄存器的高半部分输出作为余数，低半部分输出作为商；否则返回步骤(2)；

现这种除法实现方式包含的"时间换空间"的思想。因为根据原理我们会发现完成一次除法运算所需的时钟周期与被除数的（二进制）位数相同，也就是在操作数（被除数和除数）给定后需要等待一段时间才能获得结果。这是此方法的局限。但是与此同时，它也有占用存储空间少，实现简单等优势。
总结下来会发现除法运算主要是重复进行的"移位"和"更新"操作，这也就对应了下面提到的除法的两个最主要的功能模块
 



三、除法器的构成模块

1.时序控制模块
(1)功能：
根据前面的原理我们可以知道除法运算主要包含"移位"和"更新"两个操作，而且这两个操作是有先后关系的：我们必须移位之后才能进行更新，并且下一次移位必须在等待上一次更新完成。所以我们需要一个时序控制模块来保证这种先后执行顺序，具体是通过将输入的主时钟进行分频，产生下图所示的两个时钟分别驱动"移位"和"更新"模块。要注意的是，必须先给"移位"模块上升沿再给"更新"模块上升沿。


(2)输入输出结构
输入输出管脚：
inReset_n:输入重置信号；
inClock：输入系统主时钟信号；
inOperateEnable:输入运算使能信号；
outShiftClock：输出移位模块时钟；
outUpdateClock：输出更新模块时钟；
实际代码见附录1A


2.移位模块
移位模块主要是为了实现两个功能：
(1)当操作数给定之后的第一次移位之前，我们需要给移位寄存器进行初始化。以10位除法器为例，我们需要一个20位移位寄存器，然后将高10位清0，被除数填入低10位；
(2)在寄存器初始化之后开始进行重复左移，我们需要对移位次数进行计数，当计数次数达到10次之后，再重新从输入端获取操作数初始化移位寄存器。


输入输出结构：


